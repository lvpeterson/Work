1.1, Explore Visible Content
1.1.1, Confi gure your browser to use your favorite integrated proxy/spideringtool. Both Burp and WebScarab can be used to passively spider the siteby monitoring and parsing web content processed by the proxy.
1.1.2, If you fi nd it useful confi gure your browser to use an extension suchas IEWatch to monitor and analyze the HTTP and HTML content beingprocessed by the browser.
1.1.3, Browse the entire application in the normal way visiting every link andURL submitting every form and proceeding through all multistep functionsto completion. Try browsing with JavaScript enabled and disabledand with cookies enabled and disabled. Many applications can handlevarious browser confi gurations and you may reach different contentand code paths within the application.
1.1.4, If the application uses authentication and you have or can create a loginaccount use this to access the protected functionality.
1.1.5, As you browse monitor the requests and responses passing throughyour intercepting proxy to gain an understanding of the kinds of databeing submitted and the ways in which the client is used to control thebehavior of the server-side application.
1.1.6, Review the site map generated by the passive spidering and identify anycontent or functionality that you have not walked through using yourbrowser. From the spider results establish where each item was discovered(for example in Burp Spider check the Linked From details). Accesseach item using your browser so that the spider parses the response fromthe server to identify any further content. Continue this step recursivelyuntil no further content or functionality is identifi ed.
1.1.7, When you have fi nished manually browsing and passively spideringyou can use your spider to actively crawl the application using the setof discovered URLs as seeds. This may sometimes uncover additionalcontent that you overlooked when working manually. Before doing anautomated crawl fi rst identify any URLs that are dangerous or likely tobreak the application session and then confi gure the spider to excludethese from its scope.
1.2, Consult Public Resources
1.2.1, Use Internet search engines and archives (such as the Wayback Machine)to identify what content they have indexed and stored for your targetapplication.
1.2.2, Use advanced search options to improve the effectiveness of your research.For example on Google you can use site: to retrieve all the content foryour target site and link: to retrieve other sites that link to it. If yoursearch identifi es content that is no longer present in the live applicationyou may still be able to view this from the search engineﾒs cache. Thisold content may contain links to additional resources that have not yetbeen removed.
1.2.3, Perform searches on any names and e-mail addresses you have discoveredin the applicationﾒs content such as contact information. Includeitems not rendered on-screen such as HTML comments. In addition toweb searches perform news and group searches. Look for any technicaldetails posted to Internet forums regarding the target application andits supporting infrastructure.
1.2.4, Review any published WSDL fi les to generate a list of function namesand parameter values potentially employed by the application.
1.3, Discover Hidden Content
1.3.1, Confi rm how the application handles requests for nonexistent items.Make some manual requests for known valid and invalid resourcesand compare the serverﾒs responses to establish an easy way to identifywhen an item does not exist.
1.3.2, Obtain listings of common fi le and directory names and common fi leextensions. Add to these lists all the items actually observed within theapplications and also items inferred from these. Try to understand thenaming conventions used by application developers. For example ifthere are pages called AddDocument.jsp and ViewDocument.jsp theremay also be pages called EditDocument.jsp and RemoveDocument.jsp.Chapter 21 n A Web Application Hackerﾒs Methodology 797
1.3.3, Review all client-side code to identify any clues about hidden server-sidecontent including HTML comments and disabled form elements.
1.3.4, Using the automation techniques described in Chapter 14 make largenumbers of requests based on your directory fi lename and fi le extensionlists. Monitor the serverﾒs responses to confi rm which items are presentand accessible.
1.3.5, Perform these content-discovery exercises recursively using new enumeratedcontent and patterns as the basis for further user-directed spideringand further automated discovery.
1.4, Discover Default Content
1.4.1, Run Nikto against the web server to detect any default or well-knowncontent that is present. Use Niktoﾒs options to maximize its effectiveness.For example you can use the ﾖroot option to specify a directoryto check for default content or -404 to specify a string that identifi es acustom File Not Found page.
1.4.2, Verify any potentially interesting fi ndings manually to eliminate anyfalse positives within the results.
1.4.3, Request the serverﾒs root directory specifying the IP address in theHost header and determine if the application responds with any differentcontent. If so run a Nikto scan against the IP address as well asthe server name.
1.4.4, Make a request to the serverﾒs root directory specifying a range ofUser-Agent headers as shown at www.useragentstring.com/pages/useragentstring.php.
1.5, Enumerate Identifi er-Specifi ed Functions
1.5.1, Identify any instances where specifi c application functions are accessed bypassing an identifi er of the function in a request parameter (for example/admin.jsp?action=editUser or /main.php?func=A21).
1.5.2, Apply the content discovery techniques used in step 1.3 to the mechanismbeing used to access individual functions. For example if the applicationuses a parameter containing a function name fi rst determine itsbehavior when an invalid function is specifi ed and try to establish aneasy way to identify when a valid function has been requested. Compilea list of common function names or cycle through the syntactic range ofidentifi ers observed to be in use. Automate the exercise to enumeratevalid functionality as quickly and easily as possible.
1.5.3, If applicable compile a map of application content based on functional pathsrather than URLs showing all the enumerated functions and the logicalpaths and dependencies between them. (See Chapter 4 for an example.)
1.6, Test for Debug Parameters
1.6.1, Choose one or more application pages or functions where hidden debugparameters (such as debug=true) may be implemented. These are mostlikely to appear in key functionality such as login search and fi le uploador download.
1.6.2, Use listings of common debug parameter names (such as debug testhide and source) and common values (such as true yes on and 1).Iterate through all permutations of these submitting each name/valuepair to each targeted function. For POST requests supply the parameterin both the URL query string and the request body. Use the techniquesdescribed in Chapter 14 to automate this exercise. For example youcan use the cluster bomb attack type in Burp Intruder to combine allpermutations of two payload lists.
1.6.3, Review the applicationﾒs responses for any anomalies that may indicatethat the added parameter has had an effect on the applicationﾒs processing.
