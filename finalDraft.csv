1.1, Explore Visible Content
1.1.1, Confi gure your browser to use your favorite integrated proxy/spideringtool. Both Burp and WebScarab can be used to passively spider the siteby monitoring and parsing web content processed by the proxy.
1.1.2, If you fi nd it useful confi gure your browser to use an extension suchas IEWatch to monitor and analyze the HTTP and HTML content beingprocessed by the browser.
1.1.3, Browse the entire application in the normal way visiting every link andURL submitting every form and proceeding through all multistep functionsto completion. Try browsing with JavaScript enabled and disabledand with cookies enabled and disabled. Many applications can handlevarious browser confi gurations and you may reach different contentand code paths within the application.
1.1.4, If the application uses authentication and you have or can create a loginaccount use this to access the protected functionality.
1.1.5, As you browse monitor the requests and responses passing throughyour intercepting proxy to gain an understanding of the kinds of databeing submitted and the ways in which the client is used to control thebehavior of the server-side application.
1.1.6, Review the site map generated by the passive spidering and identify anycontent or functionality that you have not walked through using yourbrowser. From the spider results establish where each item was discovered(for example in Burp Spider check the Linked From details). Accesseach item using your browser so that the spider parses the response fromthe server to identify any further content. Continue this step recursivelyuntil no further content or functionality is identifi ed.
1.1.7, When you have fi nished manually browsing and passively spideringyou can use your spider to actively crawl the application using the setof discovered URLs as seeds. This may sometimes uncover additionalcontent that you overlooked when working manually. Before doing anautomated crawl fi rst identify any URLs that are dangerous or likely tobreak the application session and then confi gure the spider to excludethese from its scope.
1.2, Consult Public Resources
1.2.1, Use Internet search engines and archives (such as the Wayback Machine)to identify what content they have indexed and stored for your targetapplication.
1.2.2, Use advanced search options to improve the effectiveness of your research.For example on Google you can use site: to retrieve all the content foryour target site and link: to retrieve other sites that link to it. If yoursearch identifi es content that is no longer present in the live applicationyou may still be able to view this from the search engine’s cache. Thisold content may contain links to additional resources that have not yetbeen removed.
1.2.3, Perform searches on any names and e-mail addresses you have discoveredin the application’s content such as contact information. Includeitems not rendered on-screen such as HTML comments. In addition toweb searches perform news and group searches. Look for any technicaldetails posted to Internet forums regarding the target application andits supporting infrastructure.
1.2.4, Review any published WSDL fi les to generate a list of function namesand parameter values potentially employed by the application.
1.3, Discover Hidden Content
1.3.1, Confi rm how the application handles requests for nonexistent items.Make some manual requests for known valid and invalid resourcesand compare the server’s responses to establish an easy way to identifywhen an item does not exist.
1.3.2, Obtain listings of common fi le and directory names and common fi leextensions. Add to these lists all the items actually observed within theapplications and also items inferred from these. Try to understand thenaming conventions used by application developers. For example ifthere are pages called AddDocument.jsp and ViewDocument.jsp theremay also be pages called EditDocument.jsp and RemoveDocument.jsp.Chapter 21 n A Web Application Hacker’s Methodology 797
1.3.3, Review all client-side code to identify any clues about hidden server-sidecontent including HTML comments and disabled form elements.
1.3.4, Using the automation techniques described in Chapter 14 make largenumbers of requests based on your directory fi lename and fi le extensionlists. Monitor the server’s responses to confi rm which items are presentand accessible.
1.3.5, Perform these content-discovery exercises recursively using new enumeratedcontent and patterns as the basis for further user-directed spideringand further automated discovery.
1.4, Discover Default Content
1.4.1, Run Nikto against the web server to detect any default or well-knowncontent that is present. Use Nikto’s options to maximize its effectiveness.For example you can use the –root option to specify a directoryto check for default content or -404 to specify a string that identifi es acustom File Not Found page.
1.4.2, Verify any potentially interesting fi ndings manually to eliminate anyfalse positives within the results.
1.4.3, Request the server’s root directory specifying the IP address in theHost header and determine if the application responds with any differentcontent. If so run a Nikto scan against the IP address as well asthe server name.
1.4.4, Make a request to the server’s root directory specifying a range ofUser-Agent headers as shown at www.useragentstring.com/pages/useragentstring.php.
1.5, Enumerate Identifi er-Specifi ed Functions
1.5.1, Identify any instances where specifi c application functions are accessed bypassing an identifi er of the function in a request parameter (for example/admin.jsp?action=editUser or /main.php?func=A21).
1.5.2, Apply the content discovery techniques used in step 1.3 to the mechanismbeing used to access individual functions. For example if the applicationuses a parameter containing a function name fi rst determine itsbehavior when an invalid function is specifi ed and try to establish aneasy way to identify when a valid function has been requested. Compilea list of common function names or cycle through the syntactic range ofidentifi ers observed to be in use. Automate the exercise to enumeratevalid functionality as quickly and easily as possible.
1.5.3, If applicable compile a map of application content based on functional pathsrather than URLs showing all the enumerated functions and the logicalpaths and dependencies between them. (See Chapter 4 for an example.)
1.6, Test for Debug Parameters
1.6.1, Choose one or more application pages or functions where hidden debugparameters (such as debug=true) may be implemented. These are mostlikely to appear in key functionality such as login search and fi le uploador download.
1.6.2, Use listings of common debug parameter names (such as debug testhide and source) and common values (such as true yes on and 1).Iterate through all permutations of these submitting each name/valuepair to each targeted function. For POST requests supply the parameterin both the URL query string and the request body. Use the techniquesdescribed in Chapter 14 to automate this exercise. For example youcan use the cluster bomb attack type in Burp Intruder to combine allpermutations of two payload lists.
1.6.3, Review the application’s responses for any anomalies that may indicatethat the added parameter has had an effect on the application’s processing.
2.1, Identify Functionality
2.1.1, Identify the core functionality that the application was created for andthe actions that each function is designed to perform when used asintended.
2.1.2, Identify the core security mechanisms employed by the application andhow they work. In particular understand the key mechanisms that handleChapter 21 n A Web Application Hacker’s Methodology 799authentication session management and access control and the functionsthat support them such as user registration and account recovery.
2.1.3, Identify all the more peripheral functions and behavior such as the useof redirects off-site links error messages and administrative and loggingfunctions.
2.1.4, Identify any functionality that diverges from the standard GUI appearanceparameter naming or navigation mechanism used elsewhere inthe application and single it out for in-depth testing.
2.2, Identify Data Entry Points
2.2.1, Identify all the different entry points that exist for introducing userinput into the application’s processing including URLs query stringparameters POST data cookies and other HTTP headers processed bythe application.
2.2.2, Examine any customized data transmission or encoding mechanismsused by the application such as a nonstandard query string format.Understand whether the data being submitted encapsulates parameternames and values or whether an alternative means of representationis being used.
2.2.3, Identify any out-of-band channels via which user-controllable or otherthird-party data is being introduced into the application’s processing.An example is a web mail application that processes and renders messagesreceived via SMTP.
2.3, Identify the Technologies Used
2.3.1, Identify each of the different technologies used on the client side such asforms scripts cookies Java applets ActiveX controls and Flash objects.
2.3.2, As far as possible establish which technologies are being used on theserver side including scripting languages application platforms andinteraction with back-end components such as databases and e-mailsystems.
2.3.3, Check the HTTP Server header returned in application responses andalso check for any other software identifi ers contained within customHTTP headers or HTML source code comments. Note that in some casesdifferent areas of the application are handled by different back-endcomponents so different banners may be received.
2.3.4, Run the Httprint tool to fi ngerprint the web server.
2.3.5, Review the results of your content-mapping exercises to identify anyinteresting-looking fi le extensions directories or other URL subsequences
2.3.6, Identify any interesting-looking script names and query string parametersthat may belong to third-party code components. Search for these onGoogle using the inurl: qualifi er to fi nd any other applications usingthe same scripts and parameters and that therefore may be using thesame third-party components. Perform a noninvasive review of thesesites because this may uncover additional content and functionality thatis not explicitly linked on the application you are attacking.
2.4, Map the Attack Surface
2.4.1, Try to ascertain the likely internal structure and functionality of theserver-side application and the mechanisms it uses behind the scenesto deliver the behavior that is visible from the client perspective. Forexample a function to retrieve customer orders is likely to be interactingwith a database.
2.4.2, For each item of functionality identify the kinds of common vulnerabilitiesthat are often associated with it. For example fi le upload functions maybe vulnerable to path traversal inter-user messaging may be vulnerableto XSS and Contact Us functions may be vulnerable to SMTP injection.See Chapter 4 for examples of vulnerabilities commonly associated withparticular functions and technologies.
2.4.3, Formulate a plan of attack prioritizing the most interesting-lookingfunctionality and the most serious of the potential vulnerabilities associatedwith it. Use your plan to guide the amount of time and effort youdevote to each of the remaining areas of this methodology.
3.1, Test Transmission of Data Via the Client
3.1.1, Locate all instances within the application where hidden form fi eldscookies and URL parameters are apparently being used to transmitdata via the client.
3.1.2, Attempt to determine the purpose that the item plays in the application’slogic based on the context in which it appears and on its nameand value.
3.1.3, Modify the item’s value in ways that are relevant to its role in theapplication’s functionality. Determine whether the application processesarbitrary values submitted in the fi eld and whether this factcan be exploited to interfere with the application’s logic or subvertany security controls.
3.1.4, If the application transmits opaque data via the client you can attack thisin various ways. If the item is obfuscated you may be able to decipherthe obfuscation algorithm and therefore submit arbitrary data within theopaque item. Even if it is securely encrypted you may be able to replaythe item in other contexts to interfere with the application’s logic. SeeChapter 5 for more details on these and other attacks.
3.1.5, If the application uses the ASP.NET ViewState test to confi rm whetherthis can be tampered with or whether it contains any sensitive information.Note that the ViewState may be used differently on differentapplication pages.
3.1.5.1, Use the ViewState analyzer in Burp Suite to confi rm whetherthe EnableViewStateMac option has been enabled meaningthat the ViewState’s contents cannot be modifi ed.
3.1.5.2, Review the decoded ViewState to identify any sensitive data itcontains.
3.1.5.3, Modify one of the decoded parameter values and reencode andsubmit the ViewState. If the application accepts the modifi edvalue you should treat the ViewState as an input channel forintroducing arbitrary data into the application’s processing.Perform the same testing on the data it contains as you wouldfor any other request parameters.
3.2, Test Client-Side Controls Over User Input
3.2.1, Identify any cases where client-side controls such as length limits andJavaScript checks are used to validate user input before it is submitted
3.2.2, Test each affected input fi eld in turn by submitting input that wouldordinarily be blocked by the client-side controls to verify whether theseare replicated on the server.
3.2.3, The ability to bypass client-side validation does not necessarily representany vulnerability. Nevertheless you should review closely what validationis being performed. Confi rm whether the application is relyingon the client-side controls to protect itself from malformed input. Alsoconfi rm whether any exploitable conditions exist that can be triggeredby such input.
3.2.4, Review each HTML form to identify any disabled elements such asgrayed-out submit buttons. For example:<input disabled=”true” name=”product”>If you fi nd any submit these to the server along with the form’s otherparameters. See whether the parameter has any effect on the server’sprocessing that you can leverage in an attack. Alternatively use anautomated proxy rule to automatically enable disabled fi elds such asBurp Proxy’s “HTML Modifi cation” rules.
3.3, Test Browser Extension Components
3.3.1, Understand the Client Application’s Operation
3.3.1.1, Set up a local intercepting proxy for the client technology under reviewand monitor all traffi c passing between the client and server. If data isserialized use a deserialization tool such as Burp’s built-in AMF supportor the DSer Burp plug-in for Java.
3.3.1.2, Step through the functionality presented in the client. Determine anypotentially sensitive or powerful functions using standard tools withinthe intercepting proxy to replay key requests or modify server responses.
3.3.2, Decompile the Client
3.3.2.1, Identify any applets employed by the application. Look for any of thefollowing fi le types being requested via your intercepting proxy:n .class .jar : Javan .swf : Flashn .xap : SilverlightChapter 21 n A Web Application Hacker’s Methodology 803You can also look for applet tags within the HTML source code ofapplication pages. For example:<applet code=”input.class” id=”TheApplet” codebase=”/scripts/”></applet>
3.3.2.2, Review all calls made to the applet’s methods from within the invokingHTML and determine whether data returned from the applet is beingsubmitted to the server. If this data is opaque (that is obfuscated orencrypted) to modify it you will probably need to decompile the appletto obtain its source code.
3.3.2.3, Download the applet bytecode by entering the URL into your browserand save the fi le locally. The name of the bytecode fi le is specifi ed inthe code attribute of the applet tag. The fi le will be located in the directoryspecifi ed in the codebase attribute if this is present. Otherwise itwill be located in the same directory as the page in which the applet tagappears.
3.3.2.4, Use a suitable tool to decompile the bytecode into source code. Forexample:C:\>jad.exe input.classParsing input.class... Generating input.jadHere are some suitable tools for decompiling different browser extensioncomponents:n Java — Jadn Flash — SWFScan Flasm/Flaren Silverlight — .NET ReflectorIf the applet is packaged into a JAR XAP or SWF fi le you can unpackit using a standard archive reader such as WinRar or WinZip.
3.3.2.5, Review the relevant source code (starting with the implementation ofthe method that returns the opaque data) to understand what processingis being performed.
3.3.2.6, Determine whether the applet contains any public methods that can beused to perform the relevant obfuscation on arbitrary input.
3.3.2.7, If it doesn’t modify the applet’s source to neutralize any validation itperforms or to allow you to obfuscate arbitrary input. You can thenrecompile the source into its original fi le format using the compilationtools provided by the vendor.
3.3.3, Attach a Debugger
3.3.3.1, For large client-side applications it is often prohibitively diffi cult todecompile the whole application modify it and repackage it without
3.3.3.2, Locate the key functions and values the application employs to drivesecurity-related business logic and place breakpoints when the targetedfunction is called. Modify the arguments or return value as needed toaffect the security bypass.
3.3.4, Test ActiveX controls
3.3.4.1, Identify any ActiveX controls employed by the application. Look forany .cab fi le types being requested via your intercepting proxy or lookfor object tags within the HTML source code of application pages. Forexample:<OBJECTclassid=”CLSID:4F878398-E58A-11D3-BEE9-00C04FA0D6BA”codebase=”https://wahh app.com/scripts/input.cab”id=”TheAxControl”></OBJECT>
3.3.4.2, It is usually possible to subvert any input validation performed withinan ActiveX control by attaching a debugger to the process and directlymodifying data being processed or altering the program’s executionpath. See Chapter 5 for more details about this kind of attack.
3.3.4.3, It is often possible to guess the purpose of different methods that anActiveX control exports based on their names and the parameterspassed to them. Use the COMRaider tool to enumerate the methodsexported by the control. Test whether any of these can be manipulatedto affect the control’s behavior and defeat any validation testsit implements.
3.3.4.4, If the control’s purpose is to gather or verify certain information aboutthe client computer use the Filemon and Regmon tools to monitor theinformation the control gathers. It is often possible to create suitableitems within the system registry and fi lesystem to fi x the inputs usedby the control and therefore affect its behavior.
3.3.4.5, Test any ActiveX controls for vulnerabilities that could be exploited toattack other users of the application. You can modify the HTML usedto invoke a control to pass arbitrary data to its methods and monitorthe results. Look for methods with dangerous-sounding names suchas LaunchExe. You can also use COMRaider to perform some basic fuzztesting of ActiveX controls to identify fl aws such as buffer overfl ows.
4.1, Understand the Mechanism
4.1.1, Establish the authentication technologies in use (for example formscertifi cates or multifactor).
4.1.2, Locate all the authentication-related functionality (including loginregistration account recovery and so on).
4.1.3, If the application does not implement an automated self-registrationmechanism determine whether any other means exists of obtainingseveral user accounts.
4.2, Test Password Quality
4.2.1, Review the application for any description of the minimum quality rulesenforced on user passwords.
4.2.2, Attempt to set various kinds of weak passwords using any self-registrationor password change functions to establish the rules actually enforced.Try short passwords alphabetic characters only single-case charactersonly dictionary words and the current username.
4.2.3, Test for incomplete validation of credentials. Set a strong and complexpassword (for example 12 characters with mixed-case letters numeralsand typographic characters). Attempt to log in using different variationson this password by removing the last character by changing acharacter’s case and by removing any special characters. If any of theselogin attempts is successful continue experimenting systematically toidentify what validation is actually being performed.
4.2.4, Having established the minimum password quality rules and the extentof password validation identify the range of values that a passwordguessingattack would need to employ to have a good probability ofsuccess. Attempt to locate any built-in accounts that may not have beensubject to the standard password complexity requirements.
4.3, Test for Username Enumeration
4.3.1, Identify every location within the various authentication functionswhere a username is submitted including via an on-screen input fi elda hidden form fi eld or a cookie. Common locations include the primarylogin self-registration password change logout and account recovery.
4.3.2, For each location submit two requests containing a valid and an invalidusername. Review every detail of the server’s responses to each pair ofrequests including the HTTP status code any redirects informationdisplayed on-screen any differences hidden in the HTML page sourceand the time taken for the server to respond. Note that some differencesmay be subtle (for example the same error message may contain minortypographical differences). You can use the history function of yourintercepting proxy to review all traffi c to and from the server. WebScarabhas a function to compare two responses to quickly highlight any differencesbetween them.
4.3.3, If you observe any differences between the responses where a valid andinvalid username is submitted repeat the test with a different pair ofvalues and confi rm that a systematic difference exists that can providea basis for automated username enumeration.Chapter 21 n A Web Application Hacker’s Methodology 807
4.3.4, Check for any other sources of information leakage within the applicationthat may enable you to compile a list of valid usernames. Examplesare logging functionality actual listings of registered users and directmention of names or e-mail addresses in source code comments.
4.3.5, Locate any subsidiary authentication that accepts a username anddetermine whether it can be used for username enumeration. Payspecifi c attention to a registration page that allows specifi cation of ausername.
4.4, Test Resilience to Password Guessing
4.4.1, Identify every location within the application where user credentialsare submitted. The two main instances typically are the main loginfunction and the password change function. The latter normally is avalid target for password-guessing attacks only if an arbitrary usernamecan be supplied.
4.4.2, At each location using an account that you control manually sendseveral requests containing the valid username but other invalidcredentials. Monitor the application’s responses to identify any differences.After about 10 failed logins if the application has not returneda message about account lockout submit a request containing validcredentials. If this request succeeds an account lockout policy probablyis not in force.
4.4.3, If you do not control any accounts attempt to enumerate or guess avalid username and make several invalid requests using this guessmonitoring for any error messages about account lockout. Of courseyou should be aware that this test may have the effect of suspending ordisabling an account belonging to another user.
4.5, Test Any Account Recovery Function
4.5.1, Identify whether the application contains any facility for users to regaincontrol of their account if they have forgotten their credentials. Thisis often indicated by a Forgot Your Password link near the main loginfunction.
4.5.2, Establish how the account recovery function works by doing a completewalk-through of the recovery process using an account you control.
4.5.3, If the function uses a challenge such as a secret question determinewhether users can set or select their own challenge during registration.If so use a list of enumerated or common usernames to harvest a list ofchallenges and review this for any that appear to be easily guessable.
4.5.4, If the function uses a password hint perform the same exercise to harvesta list of password hints and identify any that appear to be easilyguessable.
4.5.5, Perform the same tests on any account-recovery challenges that you performedat the main login function to assess vulnerability to automatedguessing attacks.
4.5.6, If the function involves sending an e-mail to the user to complete therecovery process look for any weaknesses that may enable you to takecontrol of other users’ accounts. Determine whether it is possible tocontrol the address to which the e-mail is sent. If the message containsa unique recovery URL obtain a number of messages using an e-mailaddress you control and attempt to identify any patterns that may enableyou to predict the URLs issued to other users. Apply the methodologydescribed in step 5.3 to identify any predictable sequences.
4.6, Test Any Remember Me Function
4.6.1, If the main login function or its supporting logic contains a RememberMe function activate this and review its effects. If this function allows theuser to log in on subsequent occasions without entering any credentialsyou should review it closely for any vulnerabilities.
4.6.2, Closely inspect all persistent cookies that are set when the Remember Mefunction is activated. Look for any data that identifi es the user explicitlyor appears to contain some predictable identifi er of the user.
4.6.3, Even where the data stored appears to be heavily encoded or obfuscatedreview this closely and compare the results of remembering several verysimilar usernames and/or passwords to identify any opportunities toreverse-engineer the original data. Apply the methodology describedin step 5.2 to identify any meaningful data.
4.6.4, Depending on your results modify the contents of your cookie in suitableways in an attempt to masquerade as other users of the application.
4.7, Test Any Impersonation Function
4.7.1, If the application contains any explicit functionality that allows oneuser to impersonate another review this closely for any vulnerabilitiesthat may enable you to impersonate arbitrary users without properauthorization.
4.7.2, Look for any user-supplied data that is used to determine the targetof the impersonation. Attempt to manipulate this to impersonateChapter 21 n A Web Application Hacker’s Methodology 809other users particularly administrative users which may enable youescalate privileges.
4.7.3, If you perform any automated password-guessing attacks against otheruser accounts look for any accounts that appear to have more than onevalid password or multiple accounts that appear to have the same password.This may indicate the presence of a backdoor password whichadministrators can use to access the application as any user.
4.8, Test Username Uniqueness
4.8.1, If the application has a self-registration function that lets you specifya desired username attempt to register the same username twice withdifferent passwords.
4.8.2, If the application blocks the second registration attempt you can exploitthis behavior to enumerate registered usernames.
4.8.3, If the application registers both accounts probe further to determine itsbehavior when a collision of username and password occurs. Attemptto change the password of one of the accounts to match that of theother. Also attempt to register two accounts with identical usernamesand passwords.
4.8.4, If the application alerts you or generates an error when a collision ofusername and password occurs you can probably exploit this to performan automated guessing attack to discover another user’s password. Targetan enumerated or guessed username and attempt to create accountsthat have this username and different passwords. When the applicationrejects a specifi c password you have probably found the existingpassword for the targeted account.
4.8.5, If the application appears to tolerate a collision of username and passwordwithout an error log in using the colliding credentials. Determinewhat happens and whether the application’s behavior can be leveragedto gain unauthorized access to other users’ accounts.
4.9, Test Predictability of Autogenerated Credentials
4.9.1, If the application automatically generates usernames or passwords tryto obtain several values in quick succession and identify any detectablesequences or patterns.
4.9.2, If usernames are generated in a predictable way extrapolate backwardsto obtain a list of possible valid usernames. You can use this as the basisfor automated password-guessing and other attacks.
4.9.3, If passwords are generated in a predictable way extrapolate the patternto obtain a list of possible passwords issued to other application users.This can be combined with any lists of usernames you obtain to performa password-guessing attack.
4.1, Check for Unsafe Transmission of Credentials
4.10.1, Walk through all authentication-related functions that involve transmissionof credentials including the main login account registrationpassword change and any page that allows viewing or updating ofuser profi le information. Monitor all traffi c passing in both directionsbetween the client and server using your intercepting proxy.
4.10.2, Identify every case in which the credentials are transmitted in eitherdirection. You can set interception rules in your proxy to fl ag messagescontaining specifi c strings.
4.10.3, If credentials are ever transmitted in the URL query string these arepotentially vulnerable to disclosure in the browser history on-screenin server logs and in the Referer header when third-party links arefollowed.
4.10.4, If credentials are ever stored in a cookie these are potentially vulnerableto disclosure via XSS attacks or local privacy attacks.
4.10.5, If credentials are ever transmitted from the server to the client thesemay be compromised via any vulnerabilities in session management oraccess controls or in an XSS attack.
4.10.6, If credentials are ever transmitted over an unencrypted connection theseare vulnerable to interception by an eavesdropper.
4.10.7, If credentials are submitted using HTTPS but the login form itself isloaded using HTTP the application is vulnerable to a man-in-the-middleattack that may be used to capture credentials.
4.11, Check for Unsafe Distribution of Credentials
4.11.1, If accounts are created via some out-of-band channel or the applicationhas a self-registration function that does not itself determine all ofa user’s initial credentials establish the means by which credentials aredistributed to new users. Common methods include sending a messageto an e-mail or postal address.Chapter 21 n A Web Application Hacker’s Methodology 811
4.11.2, If the application generates account activation URLs that are distributedout-of-band try to register several new accounts in close successionand identify any sequence in the URLs you receive. If a pattern canbe determined try to predict the URLs sent to recent and forthcomingusers and attempt to use these URLs to take ownership of theiraccounts.
4.11.3, Try to reuse a single activation URL multiple times and see if the applicationallows this. If it doesn’t try locking out the target account beforereusing the URL and see if the URL still works. Determine whether thisenables you to set a new password on an active account.
4.12, Test for Insecure Storage
4.12.1, If you gain access to hashed passwords check for accounts that sharethe same hashed password value. Try to log in with common passwordsfor the most common hashed value.
4.12.2, Use an offl ine rainbow table for the hashing algorithm in question torecover the cleartext value.
4.13, Test for Logic Flaws
4.13.1, Test for Fail-Open Conditions
4.13.1.1, For each function in which the application checks a user’s credentialsincluding the login and password change functions walk through theprocess in the normal way using an account you control. Note everyrequest parameter submitted to the application.
4.13.1.2, Repeat the process numerous times modifying each parameter in turnin various unexpected ways designed to interfere with the application’slogic. For each parameter include the following changes:n Submit an empty string as the value.n Remove the name/value pair.n Submit very long and very short values.n Submit strings instead of numbers and vice versa.n Submit the same named parameter multiple times with the sameand different values.
4.13.1.3, Review closely the application’s responses to the preceding requests. Ifany unexpected divergences from the base case occur feed this observationback into your framing of further test cases. If one modifi cationcauses a change in behavior try to combine this with other changes topush the application’s logic to its limits.
4.13.2, Test Any Multistage Mechanisms
4.13.2.1, If any authentication-related function involves submitting credentialsin a series of different requests identify the apparent purpose of eachdistinct stage and note the parameters submitted at each stage.
4.13.2.2, Repeat the process numerous times modifying the sequence of requestsin ways designed to interfere with the application’s logic includingthe following tests:n Proceed through all stages but in a different sequence than the oneintended.n Proceed directly to each stage in turn and continue the normalsequence from there.n Proceed through the normal sequence several times skipping eachstage in turn and continuing the normal sequence from the next stage.n On the basis of your observations and the apparent purpose of eachstage of the mechanism try to think of further ways to modify thesequence and to access the different stages that the developers maynot have anticipated.
4.13.2.3, Determine whether any single piece of information (such as the username)is submitted at more than one stage either because it is capturedmore than once from the user or because it is transmitted via the clientin a hidden form fi eld cookie or preset query string parameter. If so trysubmitting different values at different stages (both valid and invalid)and observing the effect. Try to determine whether the submitted itemis sometimes superfl uous or is validated at one stage and then trustedsubsequently or is validated at different stages against different checks.Try to exploit the application’s behavior to gain unauthorized accessor reduce the effectiveness of the controls imposed by the mechanism.
4.13.2.4, Look for any data that is transmitted via the client that has not beencaptured from the user at any point. If hidden parameters are usedChapter 21 n A Web Application Hacker’s Methodology 813to track the state of the process across successive stages it may bepossible to interfere with the application’s logic by modifying theseparameters in crafted ways.
4.13.2.5, If any part of the process involves the application’s presenting a randomlyvarying challenge test for two common defects:n If a parameter specifying the challenge is submitted along with theuser’s response determine whether you can effectively choose yourown challenge by modifying this value.n Try proceeding as far as the varying challenge several times withthe same username and determine whether a different challengeis presented. If it is you can effectively choose your own challengeby proceeding to this stage repeatedly until your desiredchallenge is presented.
4.14, Exploit Any Vulnerabilities to GainUnauthorized Access
4.14.1, Review any vulnerabilities you have identifi ed within the various authenticationfunctions and identify any that you can leverage to achieveyour objectives in attacking the application. This typically involvesattempting to authenticate as a different user — if possible a user withadministrative privileges.
4.14.2, Before mounting any kind of automated attack note any accountlockout defenses you have identifi ed. For example when performingusername enumeration against a login function submit a commonpassword with each request rather than a completely arbitrary valueso as not to waste a failed login attempt on every username discovered.Similarly perform any password-guessing attacks on a breadth-fi rstnot depth-fi rst basis. Start your word list with the most common weakpasswords and proceed through this list trying each item againstevery enumerated username.
4.14.3, Take account of the password quality rules and the completeness ofpassword validation when constructing word lists to use in any passwordguessingattack to avoid impossible or superfl uous test cases.
4.14.4, Use the techniques described in Chapter 14 to automate as muchwork as possible and maximize the speed and effectiveness of yourattacks.
5.1, Understand the Mechanism
5.1.1, Analyze the mechanism used to manage sessions and state. Establishwhether the application uses session tokens or some other method ofhandling the series of requests received from each user. Note that someauthentication technologies (such as HTTP authentication) may notrequire a full session mechanism to reidentify users post-authentication.Also some applications use a sessionless state mechanism in which allstate information is transmitted via the client usually in an encryptedor obfuscated form.
5.1.2, If the application uses session tokens confi rm precisely which piecesof data are actually used to reidentify users. Items that may be used totransmit tokens include HTTP cookies query string parameters andhidden form fi elds. Several different pieces of data may be used collectivelyto reidentify the user and different items may be used by differentback-end components. Often items that look like session tokens maynot actually be employed as such by the application such as the defaultcookie generated by the web server.Chapter 21 n A Web Application Hacker’s Methodology 815
5.1.3, To verify which items are actually being employed as session tokensfi nd a page or function that is certainly session-dependent (such as auser-specifi c My Details page). Then make several requests for it systematicallyremoving each item you suspect is being used as a sessiontoken. If removing an item stops the session-dependent page from beingreturned this may confi rm that the item is a session token. Burp Repeateris a useful tool for performing these tests.
5.1.4, Having established which items of data are actually being used to reidentifyusers for each token confi rm whether it is being validated in itsentirety or whether some subcomponents of the token are ignored.Change the token’s value 1 byte at a time and check whether the modified value is still accepted. If you fi nd that certain portions of the tokenare not actually used to maintain session state you can exclude thesefrom further analysis.
5.2, Test Tokens for Meaning
5.2.1, Log in as several different users at different times and record the tokensreceived from the server. If self-registration is available and you can chooseyour username log in with a series of similar usernames that have smallvariations such as A AA AAA AAAA AAAB AAAC AABA and soon. If other user-specifi c data is submitted at the login or is stored in userprofi les (such as an e-mail address) perform a similar exercise to modifythat data systematically and capture the resulting tokens.
5.2.2, Analyze the tokens you receive for any correlations that appear to berelated to the username and other user-controllable data.
5.2.3, Analyze the tokens for any detectable encoding or obfuscation. Lookfor a correlation between the length of the username and the length ofthe token which strongly indicates that some kind of obfuscation orencoding is in use. Where the username contains a sequence of the samecharacter look for a corresponding character sequence in the tokenwhich may indicate the use of XOR obfuscation. Look for sequences inthe token that contain only hexadecimal characters which may indicatehexadecimal encoding of an ASCII string or other information. Look forsequences ending in an equals sign and/or containing only the othervalid Base64 characters: a to z A to Z 0 to 9 + and /.
5.2.4, If you can identify any meaningful data within your sample of sessiontokens consider whether this is suffi cient to mount an attack that attemptsto guess the tokens recently issued to other application users. Find apage of the application that is session-dependent and use the techniques
5.3, Test Tokens for Predictability
5.3.1, Generate and capture a large number of session tokens in quick successionusing a request that causes the server to return a new token (forexample a successful login request).
5.3.2, Attempt to identify any patterns within your sample of tokens. In allcases you should use Burp Sequencer as described in Chapter 7 toperform detailed statistical tests of the randomness properties of theapplication’s tokens. Depending on the results it may also be useful toperform the following manual analysis:n Apply your understanding of which tokens and subsequences theapplication actually uses to reidentify users. Ignore any data that isnot used in this way even if it varies between samples.n If it is unclear what type of data is contained in the token or in anyindividual component of it try applying various decodings (for exampleBase64) to see if any more meaningful data emerges. It may benecessary to apply several decodings in sequence.n Try to identify any patterns in the sequences of values contained ineach decoded token or component. Calculate the differences betweensuccessive values. Even if these appear to be chaotic there may be afixed set of observed differences which narrows down the scope ofany brute-force attack considerably.n Obtain a similar sample of tokens after waiting for a few minutesand repeat the same analysis. Try to detect whether any of the tokens’content is time-dependent.
5.3.3, If you identify any patterns capture a second sample of tokens usinga different IP address and a different username. This will help youidentify whether the same pattern is detected and whether tokensreceived in the fi rst exercise could be extrapolated to guess tokensreceived in the second.
5.3.4, If you can identify any exploitable sequences or time dependenciesconsider whether this is suffi cient to mount an attack that attemptsto guess the tokens recently issued to other application users. Use thetechniques described in Chapter 14 to automate the task of generatingand testing possible tokens. Except in the simplest kind of sequencesit is likely that your attack will need to involve a customized scriptof some kind.Chapter 21 n A Web Application Hacker’s Methodology 817
5.3.5, If the session ID appears to be custom-written use the “bit fl ipper”payload source in Burp Intruder to sequentially modify each bit in thesession token in turn. Grep for a string in the response that indicateswhether modifying the token has not resulted in an invalid session andwhether the session belongs to a different user.
5.4, Check for Insecure Transmission of Tokens
5.4.1, Walk through the application as normal starting with unauthenticatedcontent at the start URL proceeding through the login process andthen going through all the application’s functionality. Make a noteof every occasion on which a new session token is issued and whichportions of your communications use HTTP and which use HTTPS.You can use the logging function of your intercepting proxy to recordthis information.
5.4.2, If HTTP cookies are being used as the transmission mechanism for sessiontokens verify whether the secure fl ag is set preventing them fromever being transmitted over HTTP connections.
5.4.3, Determine whether in the normal use of the application session tokensare ever transmitted over an HTTP connection. If so they are vulnerableto interception.
5.4.4, In cases where the application uses HTTP for unauthenticated areasand switches to HTTPS for the login and/or authenticated areas ofthe application verify whether a new token is issued for the HTTPSportion of the communications or whether a token issued during theHTTP stage remains active when the application switches to HTTPS.If a token issued during the HTTP stage remains active the token isvulnerable to interception.
5.4.5, If the HTTPS area of the application contains any links to HTTP URLsfollow these and verify whether the session token is submitted. If it isdetermine whether it continues to be valid or is immediately terminatedby the server.
5.5, Check for Disclosure of Tokens in Logs
5.5.1, If your application mapping exercises identifi ed any logging monitoringor diagnostic functionality review these functions closely to determinewhether any session tokens are disclosed within them. Confi rm who isnormally authorized to access these functions. If they are intended foradministrators only determine whether any other vulnerabilities existthat could enable a lower-privileged user to access them.
5.5.2, Identify any instances where session tokens are transmitted within theURL. It may be that tokens are generally transmitted in a more securemanner but that developers have used the URL in specifi c cases towork around a particular problem. If so these may be transmitted inthe Referer header when users follow any off-site links. Check for anyfunctionality that enables you to inject arbitrary off-site links into pagesviewed by other users.
5.5.3, If you fi nd any way to gather valid session tokens issued to other userslook for a way to test each token to determine whether it belongs to anadministrative user (for example by attempting to access a privilegedfunction using the token).
5.6, Check Mapping of Tokens to Sessions
5.6.1, Log in to the application twice using the same user account either fromdifferent browser processes or from different computers. Determinewhether both sessions remain active concurrently. If they do the applicationsupports concurrent sessions enabling an attacker who hascompromised another user’s credentials to use these without risk ofdetection.
5.6.2, Log in and log out several times using the same user account either fromdifferent browser processes or from different computers. Determinewhether a new session token is issued each time or whether the sametoken is issued every time the same account logs in. If the latter occursthe application is not really employing proper session tokens but isusing unique persistent strings to reidentify each user. In this situationthere is no way to protect against concurrent logins or properly enforcesession timeout.
5.6.3, If tokens appear to contain any structure and meaning attempt to separateout components that may identify the user from those that appear to beinscrutable. Try to modify any user-related components of the token sothat they refer to other known users of the application. Verify whetherthe application accepts the resulting token and whether it enables youto masquerade as that user. See Chapter 7 for examples of this kind ofsubtle vulnerability.
5.7, Test Session Termination
5.7.1, When testing for session timeout and logout fl aws focus solely on theserver’s handling of sessions and tokens rather than any events that occuron the client. In terms of session termination nothing much depends onwhat happens to the token within the client browser.Chapter 21 n A Web Application Hacker’s Methodology 819
5.7.2, Check whether session expiration is implemented on the server:n Log in to the application to obtain a valid session token.n Wait for a period without using this token and then submit a requestfor a protected page (such as My Details) using the token.n If the page is displayed normally the token is still active.n Use trial and error to determine how long any session expirationtimeout is or whether a token can still be used days after the previousrequest that used it. Burp Intruder can be configured to incrementthe time interval between successive requests to automate this task.
5.7.3, Check whether a logout function exists. If it does test whether it effectivelyinvalidates the user’s session on the server. After logging outattempt to reuse the old token and determine whether it is still valid byrequesting a protected page using the token. If the session is still activeusers remain vulnerable to some session hijacking attacks even afterthey have “logged out.” You can use Burp Repeater to keep sending aspecifi c request from the proxy history to see whether the applicationresponds differently after you log out.
5.8, Check for Session Fixation
5.8.1, If the application issues session tokens to unauthenticated users obtaina token and perform a login. If the application does not issue a freshtoken following a successful login it is vulnerable to session fi xation.
5.8.2, Even if the application does not issue session tokens to unauthenticatedusers obtain a token by logging in and then return to the login page. Ifthe application is willing to return this page even though you are alreadyauthenticated submit another login as a different user using the sametoken. If the application does not issue a fresh token after the secondlogin it is vulnerable to session fi xation.
5.8.3, Identify the format of session tokens that the application uses. Modifyyour token to an invented value that is validly formed and attempt tolog in. If the application allows you to create an authenticated sessionusing an invented token it is vulnerable to session fi xation.
5.8.4, If the application does not support login but processes sensitive userinformation (such as personal and payment details) and allows this tobe displayed after submission (such as on a Verify My Order page)carry out the preceding three tests in relation to the pages displayingsensitive data. If a token set during anonymous usage of the applicationcan later be used to retrieve sensitive user information the applicationis vulnerable to session fi xation.
5.9, Check for CSRF
5.9.1, If the application relies solely on HTTP cookies as its method of transmittingsession tokens it may be vulnerable to cross-site request forgeryattacks.
5.9.2, Review the application’s key functionality and identify the specifi crequests that are used to perform sensitive actions. If an attacker canfully determine in advance parameters for any of these requests (thatis they do not contain any session tokens unpredictable data or othersecrets) the application is almost certainly vulnerable.
5.9.3, Create an HTML page that will issue the desired request without anyuser interaction. For GET requests you can place an <img> tag with thesrc parameter set to the vulnerable URL. For POST requests you cancreate a form that contains hidden fi elds for all the relevant parametersrequired for the attack and that has its target set to the vulnerableURL. You can use JavaScript to autosubmit the form as soon as thepage loads. While logged in to the application use the same browserto load your HTML page. Verify that the desired action is carried outwithin the application.
5.9.4, If the application uses additional tokens within requests in an attempt toprevent CSRF attacks test the robustness of these in the same manner asfor session tokens. Also test whether the application is vulnerable to UIredress attacks in order to defeat the anti-CSRF defenses (see Chapter 13for more details).
5.1, Check Cookie Scope
5.10.1, If the application uses HTTP cookies to transmit session tokens (orany other sensitive data) review the relevant Set-Cookie headers andcheck for any domain or path attributes used to control the scope of thecookies.
5.10.2, If the application explicitly liberalizes its cookies’ scope to a parentdomain or parent directory it may be leaving itself vulnerable to attacksvia other web applications that are hosted within the parent domainor directory.
5.10.3, If the application sets its cookies’ domain scope to its own domainname (or does not specify a domain attribute) it may still be exposedto attacks via any applications hosted on subdomains. This is a consequenceof how cookie scoping works. It cannot be avoided other thanby not hosting any other applications on a subdomain of a securitysensitiveapplication.Chapter 21 n A Web Application Hacker’s Methodology 821
5.10.4, Determine any reliance on segregation by path such as /site/main and/site/demo which can be subverted in the event of a cross-site scriptingattack.
5.10.5, Identify all the possible domain names and paths that will receive thecookies that the application issues. Establish whether any other webapplications are accessible via these domain names or paths that youmay be able to leverage to capture the cookies issued to users of thetarget application.
6.1, Understand the Access Control Requirements
6.1.1, Based on the core functionality implemented within the applicationunderstand the broad requirements for access control in terms of verticalsegregation (different levels of users have access to different typesof functionality) and horizontal segregation (users at the same privilegelevel have access to different subsets of data). Often both types of segregationare present. For example ordinary users may be able to accesstheir own data while administrators can access everyone’s data.
6.1.2, Review your application mapping results to identify the areas of functionalityand types of data resources that represent the most fruitfultargets for privilege escalation attacks.
6.1.3, To perform the most effective testing for access control vulnerabilitiesyou should ideally obtain a number of different accounts with differentvertical and horizontal privileges. If self-registration is possible you canprobably obtain the latter directly from the application. To obtain theformer you will probably need the cooperation of the application owner(or need to exploit some vulnerability to gain access to a high-privilegedaccount). The availability of different kinds of accounts will affect thetypes of testing you can perform as described next.
6.2, Test with Multiple Accounts
6.2.1, If the application enforces vertical privilege segregation fi rst use apowerful account to locate all the functionality it can access. Thenuse a less-privileged account and attempt to access each item of thisfunctionality.
6.2.1.1, Using Burp browse all the application’s content within one usercontext.
6.2.1.2, Review the contents of Burp’s site map to ensure you haveidentifi ed all the functionality you want to test. Then log outof the application and log back in using a different user context.Use the context menu to select the “compare site maps” featureto determine which high-privileged requests may be accessible tothe lower-privileged user. See Chapter 8 for more details onthis technique.
6.2.2, If the application enforces horizontal privilege segregation performthe equivalent test using two different accounts at the same privilegelevel attempting to use one account to access data belonging to theother account. This typically involves replacing an identifi er (such asa document ID) within a request to specify a resource belonging to theother user.
6.2.3, Perform manual checking of key access control logic.
6.2.3.1, For each user privilege review resources available to a user.Attempt to access those resources from an unauthorized useraccount by replaying the request using the unauthorized user’ssession token.
6.2.4, When you perform any kind of access control test be sure to test every stepof multistage functions individually to confi rm whether access controlshave been properly implemented at each stage or whether the applicationassumes that users who access a later stage must have passed securitychecks implemented at the earlier stages. For example if an administrativepage containing a form is properly protected check whether the actualform submission is also subjected to proper access controls.
6.3, Test with Limited Access
6.3.1, If you do not have prior access to accounts at different privilege levels orto multiple accounts with access to different data testing for broken accesscontrols is not quite as straightforward. Many common vulnerabilities willbe much harder to locate because you do not know the names of the URLsidentifi ers and parameters that are needed to exploit the weaknesses.Chapter 21 n A Web Application Hacker’s Methodology 823
6.3.2, In your application mapping exercises that use a low-privileged accountyou may have identifi ed the URLs for privileged functions such asadministrative interfaces. If these are not adequately protected you willprobably already know about this.
6.3.3, Decompile all compiled clients that are present and extract any referencesto server-side functionality.
6.3.4, Most data that is subject to horizontal access controls is accessed usingan identifi er such as an account number or order reference. To testwhether access controls are effective using only a single account youmust try to guess or discover the identifi ers associated with other users’data. If possible generate a series of identifi ers in quick succession(for example by creating several new orders). Attempt to identify anypatterns that may enable you to predict the identifi ers issued to otherusers. If there is no way to generate new identifi ers you are probablyrestricted to analyzing those you already have and guessing on thatbasis.
6.3.5, If you fi nd a way to predict the identifi ers issued to other users use thetechniques described in Chapter 14 to mount an automated attack toharvest interesting data belonging to other users. Use the Extract Grepfunction in Burp Intruder to capture the relevant information from withinthe application’s responses.
6.4, Test for Insecure Access Control Methods
6.4.1, Some applications implement access controls based on requestparameters in an inherently unsafe way. Look for parameters suchas edit=false or access=read in any key requests and modify thesein line with their apparent role to try to interfere with the application’saccess control logic.
6.4.2, Some applications base access control decisions on the HTTP Refererheader. For example an application may properly control access to/admin.jsp and accept any request showing this as its Referer. To testfor this behavior attempt to perform some privileged actions to whichyou are authorized and submit a missing or modifi ed Referer header.If this change causes the application to block your request it may beusing the Referer header in an unsafe way. Try performing the sameaction as an unauthorized user but supply the original Referer headerand see whether the action succeeds.
6.4.3, If HEAD is an allowed method on the site test for insecure containermanagedaccess control to URLs. Make a request using the HEAD methodto determine whether the application permits it.
7.1, Fuzz All Request Parameters
7.1.1, Review the results of your application mapping exercises and identifyevery distinct client request that submits parameters that the server-sideapplication processes. Relevant parameters include items within the URLquery string parameters in the request body and HTTP cookies. Alsoinclude any other items of user input that have been observed to have aneffect on the application’s behavior such as the Referer or User-Agentheaders.
7.1.2, To fuzz the parameters you can use your own scripts or a ready-madefuzzing tool. For example to use Burp Intruder load each request inturn into the tool. An easy way to do this is to intercept a request in BurpProxy and select the Send to Intruder action or right-click an item in theBurp Proxy history and select this option. Using this option confi guresBurp Intruder with the contents of the request along with the correcttarget host and port. It also automatically marks the values of all requestparameters as payload positions ready for fuzzing.
7.1.3, Using the payloads tab confi gure a suitable set of attack payloads toprobe for vulnerabilities within the application. You can enter payloadsmanually load them from a fi le or select one of the preset payload lists.Fuzzing every request parameter within the application typically entailsissuing a large number of requests and reviewing the results for anomalies.If your set of attack strings is too large this can be counterproductiveChapter 21 n A Web Application Hacker’s Methodology 825and generate a prohibitively large amount of output for you to review.Hence a sensible approach is to target a range of common vulnerabilitiesthat can often be easily detected in anomalous responses to specifi ccrafted inputs and that often manifest themselves anywhere withinthe application rather than within specifi c types of functionality. Hereis a suitable set of payloads that you can use to test for some commoncategories of vulnerabilities:SQL Injection‘‘--‘; waitfor delay ‘0:30:0’--
1,; waitfor delay ‘0:30:0’--XSS and Header Injectionxsstest“><script>alert(‘xss’)</script>OS Command Injection|| ping -i 30 127.0.0.1 ; x || ping -n 30 127.0.0.1 &| ping –i 30 127.0.0.1 || ping –n 30 127.0.0.1 |& ping –i 30 127.0.0.1 && ping –n 30 127.0.0.1 &; ping 127.0.0.1 ;%0a ping –i 30 127.0.0.1 %0a` ping 127.0.0.1 `Path Traversal../../../../../../../../../../etc/passwd../../../../../../../../../../boot.ini..\..\..\..\..\..\..\..\..\..\etc\passwd..\..\..\..\..\..\..\..\..\..\boot.iniScript Injection;echo 111111echo 111111response.write 111111:response.write 111111File Inclusionhttp://<your server name>/http://<nonexistent IP address>/
7.1.4, All the preceding payloads are shown in their literal form. The characters? ; & + = and space need to be URL-encoded because they have special
826, Chapter 21 n A Web Application Hacker’s Methodologymeaning within HTTP requests. By default Burp Intruder performs thenecessary encoding of these characters so ensure that this option has notbeen disabled. (To restore all options to their defaults following earliercustomization select Burp ‚ Restore Defaults.)
7.1.5, In the Grep function of Burp Intruder confi gure a suitable set of stringsto fl ag some common error messages within responses. For example:errorexceptionillegalinvalidfailstackaccessdirectoryfilenot foundvarcharODBCSQLSELECT
111111,Note that the string 111111 is included to test for successful script injectionattacks. The payloads in step 7.1.3 involve writing this value intothe server’s response.
7.1.6, Also select the Payload Grep option to fl ag responses that contain thepayload itself indicating a potential XSS or header injection vulnerability.
7.1.7, Set up a web server or netcat listener on the host you specifi ed in thefi rst fi le inclusion payload. This helps you monitor for connectionattempts received from the server resulting from a successful remotefi le inclusion attack.
7.1.8, Launch the attack. When it has completed review the results for anomalousresponses indicating the presence of vulnerabilities. Check fordivergences in the HTTP status code the response length the responsetime the appearance of your confi gured expressions and the appearanceof the payload itself. You can click each column heading in the resultstable to sort the results by the values in that column (and Shift-clickto reverse-sort the results). This enables you to quickly identify anyanomalies that stand out from the other results.
7.1.9, For each potential vulnerability indicated by the results of your fuzz testingrefer to the following sections of this methodology. They describethe detailed steps you should take in relation to each category of problemto verify the existence of a vulnerability and successfully exploit it.Chapter 21 n A Web Application Hacker’s Methodology 827
7.1.10, After you have confi gured Burp Intruder to perform a fuzz test of a singlerequest you can quickly repeat the same test on other requests withinthe application. Simply select each target request within Burp Proxy andchoose the Send to Intruder option. Then immediately launch the attackwithin Intruder using the existing attack confi guration. In this way youcan launch a large number of tests simultaneously in separate windowsand manually review the results as each test completes its work.
7.1.11, If your mapping exercises identifi ed any out-of-band input channelswhereby user-controllable input can be introduced into the application’sprocessing you should perform a similar fuzzing exercise on these inputchannels. Submit various crafted data designed to trigger common vulnerabilitieswhen processed within the web application. Depending onthe nature of the input channel you may need to create a custom scriptor other harness for this purpose.
7.1.12, In addition to your own fuzzing of application requests if you have accessto an automated web application vulnerability scanner you should runit against the target application to provide a basis for comparison withyour own fi ndings.
7.2, Test for SQL Injection
7.2.1, If the SQL attack strings listed in step 7.1.3 result in any anomalousresponses probe the application’s handling of the relevant parametermanually to determine whether a SQL injection vulnerability is present.
7.2.2, If any database error messages were returned investigate their meaning.Use the section “SQL Syntax and Error Reference” in Chapter 9 to helpinterpret error messages on some common database platforms.
7.2.3, If submitting a single quotation mark in the parameter causes an erroror other anomalous behavior submit two single quotation marks. If thisinput causes the error or anomalous behavior to disappear the applicationis probably vulnerable to SQL injection.
7.2.4, Try using common SQL string concatenator functions to construct a stringthat is equivalent to some benign input. If this causes the same responseas the original benign input the application is probably vulnerable. Forexample if the original input is the expression FOO you can performthis test using the following items (in the third example note the spacebetween the two quotes):‘||’FOO‘+’FOO‘ ‘FOO
7.2.5, If the original input is numeric try using a mathematical expression thatis equivalent to the original value. For example if the original value was
2, try submitting 1+1 or 3–1. If the application responds in the same wayit may be vulnerable particularly if the value of the numeric expressionhas a systematic effect on the application’s behavior.
7.2.6, If the preceding test is successful you can gain further assurance thata SQL injection vulnerability is involved by using SQL-specifi c mathematicalexpressions to construct a particular value. If the application’slogic can be systematically manipulated in this way it is almost certainlyvulnerable to SQL injection. For example both of the following itemsare equivalent to the number 2:
67,#NAME?
51,#NAME?
7.2.7, If either of the fuzz test cases using the waitfor command resultedin an abnormal time delay before the application responded this is astrong indicator that the database type is MS-SQL and the applicationis vulnerable to SQL injection. Repeat the test manually specifying differentvalues in the waitfor parameter and determine whether the timetaken to respond varies systematically with this value. Note that yourattack payload may be inserted into more than one SQL query so thetime delay observed may be a fi xed multiple of the value specifi ed.
7.2.8, If the application is vulnerable to SQL injection consider what kindsof attacks are feasible and likely to help you achieve your objectives.Refer to Chapter 9 for the detailed steps needed to carry out any of thefollowing attacks:n Modify the conditions within a WHERE clause to change the application’slogic (for example by injecting or 1=1-- to bypass a login).n Use the UNION operator to inject an arbitrary SELECT query and combinethe results with those of the application’s original query.n Fingerprint the database type using database-specific SQL syntax.n If the database type is MS-SQL and the application returns ODBC errormessages in its responses leverage these to enumerate the databasestructure and retrieve arbitrary data.n If you cannot find a way to directly retrieve the results of an arbitraryinjected query use the following advanced techniques to extract data:n Retrieve string data in numeric form one byte at a time.n Use an out-of-band channel.Chapter 21 n A Web Application Hacker’s Methodology 829n If you can cause different application responses based on a singlearbitrary condition use Absinthe to extract arbitrary data one bitat a time.n If you can trigger time delays based on a single arbitrary conditionexploit these to retrieve data one bit at a time.n If the application is blocking certain characters or expressions thatyou require to perform a particular attack try the various bypasstechniques described in Chapter 9 to circumvent the input filter.n If possible escalate the attack against the database and the underlyingserver by leveraging any vulnerabilities or powerful functionswithin the database.
7.3, Test for XSS and Other Response Injection
7.3.1, Identify Refl ected Request Parameters
7.3.1.1, Sort the results of your fuzz testing by clicking the Payload Grep columnand identify any matches corresponding to the XSS payloads listed instep 7.1.3. These are cases where the XSS test strings were returnedunmodifi ed within the application’s responses.
7.3.1.2, For each of these cases review the application’s response to fi nd the locationof the supplied input. If this appears within the response body testfor XSS vulnerabilities. If the input appears within any HTTP header testfor header injection vulnerabilities. If it is used in the Location headerof a 302 response or if it is used to specify a redirect in some other waytest for redirection vulnerabilities. Note that the same input might becopied into multiple locations within the response and that more thanone type of refl ected vulnerability might be present.
7.3.2, Test for Refl ected XSS
7.3.2.1, For each place within the response body where the value of the requestparameter appears review the surrounding HTML to identify possibleways of crafting your input to cause execution of arbitrary JavaScript.For example you can inject <script> tags inject into an existing scriptor place a crafted value into a tag attribute.
7.3.2.2, Use the different methods of beating signature-based fi lters described inChapter 12 as a reference for the different ways in which crafted inputcan be used to cause execution of JavaScript.
7.3.2.3, Try submitting various possible exploits to the application and monitorits responses to determine whether any fi ltering or sanitization of input
830, Chapter 21 n A Web Application Hacker’s Methodologyis being performed. If your attack string is returned unmodifi ed use abrowser to verify conclusively that you have succeeded in executingarbitrary JavaScript (for example by generating an alert dialog).
7.3.2.4, If you fi nd that the application is blocking input containing certaincharacters or expressions you need to use or is HTML-encoding certaincharacters try the various fi lter bypasses described in Chapter 12.
7.3.2.5, If you fi nd an XSS vulnerability in a POST request this can still beexploited via a malicious website that contains a form with the requiredparameters and a script to automatically submit the form. Neverthelessa wider range of attack delivery mechanisms is available if the exploitcan be delivered via a GET request. Try submitting the same parametersin a GET request and see if the attack still succeeds. You can use theChange Request Method action in Burp Proxy to convert the requestfor you.
7.3.3, Test for HTTP Header Injection
7.3.3.1, For each place within the response headers where the value of the requestparameter appears verify whether the application accepts data containingURL-encoded carriage-return (%0d) and line-feed (%0a) charactersand whether these are returned unsanitized in its response. (Note thatyou are looking for the actual newline characters themselves to appearin the server’s response not their URL-encoded equivalents.)
7.3.3.2, If a new line appears in the server’s response headers when you supplycrafted input the application is vulnerable to HTTP header injection.This can be leveraged to perform various attacks as described inChapter 13.
7.3.3.3, If you fi nd that only one of the two newline characters gets returned inthe server’s responses it may still be possible to craft a working exploitdepending on the context and the target user’s browser.
7.3.3.4, If you fi nd that the application blocks input containing newline charactersor sanitizes those characters in its response try the following itemsof input to test the fi lter’s effectiveness:foo%00%0d%0abarfoo%250d%250abarfoo%%0d0d%%0a0abar
7.3.4, Test for Open Redirection
7.3.4.1, If the refl ected input is used to specify the target of a redirect of somekind test whether it is possible to supply crafted input that results inChapter 21 n A Web Application Hacker’s Methodology 831an arbitrary redirect to an external website. If so this behavior can beexploited to lend credibility to a phishing-style attack.
7.3.4.2, If the application ordinarily transmits an absolute URL as the parameter’svalue modify the domain name within the URL and test whether theapplication redirects you to the different domain.
7.3.4.3, If the parameter normally contains a relative URL modify this into anabsolute URL for a different domain and test whether the applicationredirects you to this domain.
7.3.4.4, If the application carries out some validation on the parameter beforeperforming the redirect in an effort to prevent external redirectionthis is often vulnerable to bypasses. Try the various attacks describedin Chapter 13 to test the robustness of the fi lters.
7.3.5, Test for Stored Attacks
7.3.5.1, If the application stores items of user-supplied input and later displays theseon-screen after you have fuzzed the entire application you may observesome of your attack strings being returned in responses to requests that didnot themselves contain those strings. Note any instances where this occursand identify the original entry point for the data that is being stored.
7.3.5.2, In some cases user-supplied data is stored successfully only if you completea multistage process which does not occur in basic fuzz testing. Ifyour application mapping exercises identifi ed any functionality of thiskind manually walk through the relevant process and test the storeddata for XSS vulnerabilities.
7.3.5.3, If you have suffi cient access to test it review closely any administrativefunctionality in which data originating from low-privileged users isultimately rendered on-screen in the session of more privileged users.Any stored XSS vulnerabilities in functionality of this kind typically leaddirectly to privilege escalation.
7.3.5.4, Test every instance where user-supplied data is stored and displayedto users. Probe these for XSS and the other response injection attacksdescribed previously.
7.3.5.5, If you fi nd a vulnerability in which input supplied by one user is displayedto other users determine the most effective attack payload with whichyou can achieve your objectives such as session hijacking or requestforgery. If the stored data is displayed only to the same user from whomit originated try to fi nd ways of chaining any other vulnerabilities youhave discovered (such as broken access controls) to inject an attack intoother users’ sessions.
7.3.5.6, If the application allows upload and download of fi les always probe thisfunctionality for stored XSS attacks. If the application allows HTML JARor text fi les and does not validate or sanitize their contents it is almostcertainly vulnerable. If it allows JPEG fi les and does not validate thatthey contain valid images it is probably vulnerable to attacks againstInternet Explorer users. Test the application’s handling of each fi le typeit supports and confi rm how browsers handle responses containingHTML instead of the normal content type.
7.3.5.7, In every location where data submitted by one user is displayed to otherusers but where the application’s fi lters prevent you from performinga stored XSS attack review whether the application’s behavior leavesit vulnerable to on-site request forgery.
7.4, Test for OS Command Injection
7.4.1, If any of the command injection attack strings listed in step 7.1.3 resultedin an abnormal time delay before the application responded this is astrong indicator that the application is vulnerable to OS command injection.Repeat the test manually specifying different values in the -i or-n parameter and determine whether the time taken to respond variessystematically with this value.
7.4.2, Using whichever of the injection strings was found to be successful tryinjecting a more interesting command (such as ls or dir) and determinewhether you can retrieve the results of the command to your browser.
7.4.3, If you are unable to retrieve results directly other options are open toyou:n You can attempt to open an out-of-band channel back to your computer.Try using TFTP to copy tools up to the server using telnet ornetcat to create a reverse shell back to your computer and using themail command to send command output via SMTP.n You can redirect the results of your commands to a file within theweb root which you can then retrieve directly using your browser.For example:dir > c:\inetpub\wwwroot\foo.txt
7.4.4, If you fi nd a way to inject commands and retrieve the results you shoulddetermine your privilege level (by using whoami or a similar commandor attempting to write a harmless fi le to a protected directory). Youmay then seek to escalate privileges gain backdoor access to sensitiveapplication data or attack other hosts that can be reached from thecompromised server.Chapter 21 n A Web Application Hacker’s Methodology 833
7.4.5, If you believe that your input is being passed to an OS command ofsome kind but the attack strings listed are unsuccessful see if you canuse the < or > character to direct the contents of a fi le to the command’sinput or to direct the command’s output to a fi le. This may enable youto read or write arbitrary fi le contents. If you know or can guess theactual command being executed try injecting command-line parametersassociated with that command to modify its behavior in useful ways(for example by specifying an output fi le within the web root).
7.4.6, If you fi nd that the application is escaping certain key characters you needto perform a command injection attack try placing the escape characterbefore each such character. If the application does not escape the escapecharacter itself this usually leads to a bypass of this defensive measure.If you fi nd that whitespace characters are blocked or sanitized you maybe able to use $IFS in place of spaces on UNIX-based platforms.
7.5, Test for Path Traversal
7.5.1, For each fuzz test you have performed review the results generatedby the path traversal attack strings listed in step 7.1.3. You can click thetop of the payload column in Burp Intruder to sort the results table bypayload and group the results for these strings. For any cases wherean unusual error message or a response with an abnormal length wasreceived review the response manually to determine whether it containsthe contents of the specifi ed fi le or other evidence that an anomalousfi le operation occurred.
7.5.2, In your mapping of the application’s attack surface you should havenoted any functionality that specifi cally supports the reading and writingof fi les on the basis of user-supplied input. In addition to the generalfuzzing of all parameters you should manually test this functionalityvery carefully to identify any path traversal vulnerabilities that exist.
7.5.3, Where a parameter appears to contain a fi lename a portion of a fi lenameor a directory modify the parameter’s existing value to insert anarbitrary subdirectory and a single traversal sequence. For example ifthe application submits this parameter:file=foo/file1.txttry submitting this value:file=foo/bar/../file1.txtIf the application’s behavior is identical in the two cases it may bevulnerable and you should proceed to the next step. If the behavioris different the application may be blocking stripping or sanitizing
834, Chapter 21 n A Web Application Hacker’s Methodologytraversal sequences resulting in an invalid fi le path. Try using theencoding and other attacks described in Chapter 10 in an attempt tobypass the fi lters.
7.5.4, If the preceding test of using traversal sequences within the basedirectory is successful try using additional sequences to step abovethe base directory and access known fi les on the server’s operatingsystem. If these attempts fail the application may be imposing variousfi lters or checks before fi le access is granted. You should probefurther to understand the controls that are implemented and whetherany bypasses exist.
7.5.5, The application may be checking the fi le extension being requestedand allowing access to only certain kinds of fi les. Try using a null byteor newline attack together with a known accepted fi le extension in anattempt to bypass the fi lter. For example:../../../../../boot.ini%00.jpg../../../../../etc/passwd%0a.jpg
7.5.6, The application may be checking that the user-supplied fi le path starts witha particular directory or stem. Try appending traversal sequences aftera known accepted stem in an attempt to bypass the fi lter. For example:/images/../../../../../../../etc/passwd
7.5.7, If these attacks are unsuccessful try combining multiple bypassesworking initially entirely within the base directory in an attempt tounderstand the fi lters in place and the ways in which the applicationhandles unexpected input.
7.5.8, If you succeed in gaining read access to arbitrary fi les on the serverattempt to retrieve any of the following fi les which may enable you toescalate your attack:n Password files for the operating system and applicationn Server and application configuration files to discover other vulnerabilitiesor fine-tune a different attackn Include files that may contain database credentialsn Data sources used by the application such as MySQL database filesor XML filesn The source code to server-executable pages to perform a code reviewin search of bugsn Application log files that may contain information such as usernamesand session tokensChapter 21 n A Web Application Hacker’s Methodology 835
7.5.9, If you succeed in gaining write access to arbitrary fi les on the serverexamine whether any of the following attacks are feasible in order toescalate your attack:n Creating scripts in users’ startup foldersn Modifying files such as in.ftpd to execute arbitrary commands whena user next connectsn Writing scripts to a web directory with execute permissions and callingthem from your browser
7.6, Test for Script Injection
7.6.1, For each fuzz test you have performed review the results for the string
111111, on its own (that is not preceded by the rest of the test string).You can quickly identify these in Burp Intruder by Shift-clicking theheading for the 111111 Grep string to group all the results containingthis string. Look for any that do not have a check in the Payload Grepcolumn. Any cases identifi ed are likely to be vulnerable to injection ofscripting commands.
7.6.2, Review all the test cases that used script injection strings and identifyany containing scripting error messages that may indicate that your inputis being executed but caused an error. These may need to be fi ne-tunedto perform successful script injection.
7.6.3, If the application appears to be vulnerable verify this by injecting furthercommands specifi c to the scripting platform in use. For exampleyou can use attack payloads similar to those used when fuzzing for OScommand injection:system(‘ping%20127.0.0.1’)
7.7, Test for File Inclusion
7.7.1, If you received any incoming HTTP connections from the target application’sinfrastructure during your fuzzing the application is almostcertainly vulnerable to remote fi le inclusion. Repeat the relevant testsin a single-threaded and time-throttled way to determine exactly whichparameters are causing the application to issue the HTTP requests.
7.7.2, Review the results of the fi le inclusion test cases and identify any thatcaused an anomalous delay in the application’s response. In these casesit may be that the application itself is vulnerable but that the resultingHTTP requests are timing out due to network-level fi lters.
7.7.3, If you fi nd a remote fi le inclusion vulnerability deploy a web servercontaining a malicious script specifi c to the language you are targetingand use commands such as those used to test for script injection to verifythat your script is being executed.
8.1, Test for SMTP Injection
8.1.1, For each request employed in e-mail–related functionality submit eachof the following test strings as each parameter in turn inserting yourown e-mail address at the relevant position. You can use Burp Intruderto automate this as described in step 7.1 for general fuzzing. These teststrings already have special characters URL-encoded so do not applyany additional encoding to them.<youremail>%0aCc:<youremail><youremail>%0d%0aCc:<youremail><youremail>%0aBcc:<youremail><youremail>%0d%0aBcc:<youremail>%0aDATA%0afoo%0a%2e%0aMAIL+FROM:+<youremail>%0aRCPT+TO:+<youremail>Chapter 21 n A Web Application Hacker’s Methodology 837%0aDATA%0aFrom:+<youremail>%0aTo:+<youremail>%0aSubject:+test%0afoo%0a%2e%0a%0d%0aDATA%0d%0afoo%0d%0a%2e%0d%0aMAIL+FROM:+<youremail>%0d%0aRCPT+TO:+<youremail>%0d%0aDATA%0d%0aFrom:+<youremail>%0d%0aTo:+<youremail>%0d%0aSubject:+test%0d%0afoo%0d%0a%2e%0d%0a
8.1.2, Review the results to identify any error messages the application returns.If these appear to relate to any problem in the e-mail function investigatewhether you need to fi ne-tune your input to exploit a vulnerability.
8.1.3, Monitor the e-mail address you specifi ed to see if any e-mail messagesare received.
8.1.4, Review closely the HTML form that generates the relevant request. Itmay contain clues regarding the server-side software being used. Itmay also contain a hidden or disabled fi eld that is used to specify theTo address of the e-mail which you can modify directly.
8.2, Test for Native Software Vulnerabilities
8.2.1, Test for Buffer Overfl ows
8.2.1.1, For each item of data being targeted submit a range of long strings withlengths somewhat longer than common buffer sizes. Target one item ofdata at a time to maximize the coverage of code paths in the application.You can use the character blocks payload source in Burp Intruder toautomatically generate payloads of various sizes. The following buffersizes are suitable to test:
1100,
4200,
33000,
8.2.1.2, Monitor the application’s responses to identify any anomalies. An uncontrolledoverfl ow is almost certain to cause an exception in the applicationalthough diagnosing the nature of the problem remotely may bediffi cult. Look for any of the following anomalies:n An HTTP 500 status code or error message where other malformed(but not overlong) input does not have the same effectn An informative message indicating that a failure occurred in someexternal native code componentn A partial or malformed response being received from the servern The TCP connection to the server closing abruptly without returninga response
8.2.2, Test for Integer Vulnerabilities
8.2.2.1, When dealing with native code components identify any integer-baseddata particularly length indicators which may be used to trigger integervulnerabilities.
8.2.2.2, Within each targeted item send suitable payloads designed to triggerany vulnerabilities. For each item of data being targeted send a seriesof different values in turn representing boundary cases for the signedand unsigned versions of different sizes of integer. For example:n 0x7f and 0x80 (127 and 128)n 0xff and 0x100 (255 and 256)n 0x7ffff and 0x8000 (32767 and 32768)n 0xffff and 0x10000 (65535 and 65536)n 0x7fffffff and 0x80000000 (2147483647 and 2147483648)n 0xffffffff and 0x0 (4294967295 and 0)
8.2.2.3, When the data being modifi ed is represented in hexadecimal form sendboth little-endian and big-endian versions of each test case such as ff7fand 7fff. If hexadecimal numbers are submitted in ASCII form usethe same case as the application itself uses for alphabetic characters toensure that these are decoded correctly.
8.2.2.4, Monitor the application’s responses for anomalous events as describedin step 8.2.1.2.
8.2.3, Test for Format String Vulnerabilities
8.2.3.1, Targeting each parameter in turn submit strings containing long sequencesof different format specifi ers. For example:%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%1!n!%2!n!%3!n!%4!n!%5!n!%6!n!%7!n!%8!n!%9!n!%10!n! etc...%1!s!%2!s!%3!s!%4!s!%5!s!%6!s!%7!s!%8!s!%9!s!%10!s! etc...Remember to URL-encode the % character as %25.
8.2.3.2, Monitor the application’s responses for anomalous events as describedin step 8.2.1.2.Chapter 21 n A Web Application Hacker’s Methodology 839
8.3, Test for SOAP Injection
8.3.1, Target each parameter in turn that you suspect is being processed viaa SOAP message. Submit a rogue XML closing tag such as </foo>. Ifno error occurs your input is probably not being inserted into a SOAPmessage or is being sanitized in some way.
8.3.2, If an error was received submit instead a valid opening and closingtag pair such as <foo></foo>. If this causes the error to disappear theapplication may be vulnerable.
8.3.3, If the item you submit is copied back into the application’s responsessubmit the following two values in turn. If you fi nd that either item isreturned as the other or as simply test you can be confi dent that yourinput is being inserted into an XML-based message.test<foo/>test<foo></foo>
8.3.4, If the HTTP request contains several parameters that may be beingplaced into a SOAP message try inserting the opening comment character<!-- into one parameter and the closing comment character !-->into another parameter. Then switch these (because you have no wayof knowing in which order the parameters appear). This can have theeffect of commenting out a portion of the server’s SOAP message whichmay change the application’s logic or result in a different error conditionthat may divulge information.
8.4, Test for LDAP Injection
8.4.1, In any functionality where user-supplied data is used to retrieve informationfrom a directory service target each parameter in turn to testfor potential injection into an LDAP query.
8.4.2, Submit the * character. If a large number of results are returned this isa good indicator that you are dealing with an LDAP query.
8.4.3, Try entering a number of closing parentheses:))))))))))This input invalidates the query syntax so if an error or other anomalousbehavior results the application may be vulnerable (although manyother application functions and injection situations may behave in thesame way).
8.4.4, Try entering various expressions designed to interfere with differenttypes of queries and see if these allow you to infl uence the results being
840, Chapter 21 n A Web Application Hacker’s Methodologyreturned. The cn attribute is supported by all LDAP implementationsand is useful if you do not know any details about the directory you arequerying:)(cn=**))(|(cn=**))%00
8.4.5, Try adding extra attributes to the end of your input using commas toseparate each item. Test each attribute in turn. An error indicates thatthe attribute is not valid in the present context. The following attributesare commonly used in directories queried by LDAP:cncmailgivennameooudcluidobjectclasspostaladdressdnsn
8.5, Test for XPath Injection
8.5.1, Try submitting the following values and determine whether they resultin different application behavior without causing an error:‘ or count(parent::*[position()=1])=0 or ‘a’=’b‘ or count(parent::*[position()=1])>0 or ‘a’=’b
8.5.2, If the parameter is numeric also try the following test strings:
1, or count(parent::*[position()=1])=0
1, or count(parent::*[position()=1])>0
8.5.3, If any of the preceding strings causes differential behavior within theapplication without causing an error it is likely that you can extractarbitrary data by crafting test conditions to extract 1 byte of informationat a time. Use a series of conditions with the following form to determinethe name of the current node’s parent:substring(name(parent::*[position()=1])11)=’a’Chapter 21 n A Web Application Hacker’s Methodology 841
8.5.4, Having extracted the name of the parent node use a series of conditionswith the following form to extract all the data within the XML tree:substring(//parentnodename[position()=1]/child::node()[position()=1]/text()11)=’a’
8.6, Test for Back-End Request Injection
8.6.1, Locate any instance where an internal server name or IP address isspecifi ed in a parameter. Submit an arbitrary server and port andmonitor the application for a timeout. Also submit localhost andfi nally your own IP address monitoring for incoming connections onthe port specifi ed.
8.6.2, Target a request parameter that returns a specifi c page for a specifi cvalue and try to append a new injected parameter using various syntaxincluding the following:%26foo%3dbar (URL-encoded &foo=bar)%3bfoo%3dbar (URL-encoded ;foo=bar)%2526foo%253dbar (Double URL-encoded &foo=bar)If the application behaves as if the original parameter were unmodifi edthere is a chance of HTTP parameter injection vulnerabilities. Attemptto attack the back-end request by injecting known parameter name/value pairs that may alter the back-end logic as described in Chapter 10.
8.7, Test for XXE Injection
8.7.1, If users are submitting XML to the server an external entity injectionattack may be possible. If a fi eld is known that is returned to the userattempt to specify an external entity as in the following example:POST /search/128/AjaxSearch.ashx HTTP/1.1Host: mdsec.netContent-Type: text/xml; charset=UTF-8Content-Length: 115<!DOCTYPE foo [ <!ENTITY xxe SYSTEM “file:///windows/win.ini” > ]><Search><SearchTerm>&xxe;</SearchTerm></Search>If no known field can be found specify an external entity of“http://192.168.1.1:25” and monitor the page response time. If thepage takes signifi cantly longer to return or times out it may be vulnerable.
9.1, Identify the Key Attack Surface
9.1.1, Logic fl aws can take a huge variety of forms and exist within any aspectof the application’s functionality. To ensure that probing for logic fl awsis feasible you should fi rst narrow down the attack surface to a reasonablearea for manual testing.
9.1.2, Review the results of your application mapping exercises and identifyany instances of the following features:n Multistage processesn Critical security functions such as loginn Transitions across trust boundaries (for example moving from beinganonymous to being self-registered to being logged in)n Context-based functionality presented to a usern Checks and adjustments made to transaction prices or quantities
9.2, Test Multistage Processes
9.2.1, When a multistage process involves a defi ned sequence of requestsattempt to submit these requests out of the expected sequence. Tryskipping certain stages accessing a single stage more than once andaccessing earlier stages after later ones.
9.2.2, The sequence of stages may be accessed via a series of GET or POSTrequests for distinct URLs or they may involve submitting differentsets of parameters to the same URL. You may specify the stage beingChapter 21 n A Web Application Hacker’s Methodology 843requested by submitting a function name or index within a requestparameter. Be sure to understand fully the mechanisms that the applicationis employing to deliver access to distinct stages.
9.2.3, In addition to interfering with the sequence of steps try taking parametersthat are submitted at one stage of the process and submitting themat a different stage. If the relevant items of data are updated within theapplication’s state you should investigate whether you can leveragethis behavior to interfere with the application’s logic.
9.2.4, If a multistage process involves different users performing operationson the same set of data try taking each parameter submitted by one userand submitting it as another. If they are accepted and processed as thatuser explore the implications of this behavior as described previously.
9.2.5, From the context of the functionality that is implemented try to understandwhat assumptions the developers may have made and where thekey attack surface lies. Try to identify ways of violating those assumptionsto cause undesirable behavior within the application.
9.2.6, When multistage functions are accessed out of sequence it is commonto encounter a variety of anomalous conditions within the applicationsuch as variables with null or uninitialized values partially defi ned orinconsistent state and other unpredictable behavior. Look for interestingerror messages and debug output which you can use to betterunderstand the application’s internal workings and thereby fi ne-tunethe current or a different attack.
9.3, Test Handling of Incomplete Input
9.3.1, For critical security functions within the application which involveprocessing several items of user input and making a decision based onthese test the application’s resilience to requests containing incompleteinput.
9.3.2, For each parameter in turn remove both the name and value of theparameter from the request. Monitor the application’s responses forany divergence in its behavior and any error messages that shed lighton the logic being performed.
9.3.3, If the request you are manipulating is part of a multistage process followthe process through to completion because the application may storedata submitted in earlier stages within the session and then process thisat a later stage.
9.4, Test Trust Boundaries
9.4.1, Probe how the application handles transitions between different typesof trust of the user. Look for functionality where a user with a giventrust status can accumulate an amount of state relating to his identity.For example an anonymous user could provide personal informationduring self-registration or proceed through part of an account recoveryprocess designed to establish his identity.
9.4.2, Try to fi nd ways to make improper transitions across trust boundariesby accumulating relevant state in one area and then switching to adifferent area in a way that would not normally occur. For examplehaving completed part of an account recovery process attempt toswitch to an authenticated user-specifi c page. Test whether the applicationassigns you an inappropriate level of trust when you transitionin this way.
9.4.3, Try to determine whether you can harness any higher-privileged functiondirectly or indirectly to access or infer information.
9.5, Test Transaction Logic
9.5.1, In cases where the application imposes transaction limits test theeffects of submitting negative values. If these are accepted it may bepossible to beat the limits by making large transactions in the oppositedirection.
9.5.2, Examine whether you can use a series of successive transactions to bringabout a state that you can exploit for a useful purpose. For example youmay be able to perform several low-value transfers between accountsto accrue a large balance that the application’s logic was intended toprevent.
9.5.3, If the application adjusts prices or other sensitive values based on criteriathat are determined by user-controllable data or actions fi rst understandthe algorithms used by the application and the point within its logicwhere adjustments are made. Identify whether these adjustments aremade on a one-time basis or whether they are revised in response tofurther actions performed by the user.
9.5.4, Try to fi nd ways to manipulate the application’s behavior to cause it toget into a state where the adjustments it has applied do not correspondto the original criteria intended by its designers.
10.1, Test Segregation in Shared Infrastructures
10.1.1, If the application is hosted in a shared infrastructure examine the accessmechanisms provided for customers of the shared environment to updateand manage their content and functionality. Consider the followingquestions:n Does the remote access facility use a secure protocol and suitablyhardened infrastructure?n Can customers access files data and other resources that they do notlegitimately need to access?n Can customers gain an interactive shell within the hosting environmentand execute arbitrary commands?
10.1.2, If a proprietary application is used to allow customers to confi gure andcustomize a shared environment consider targeting this application asa way to compromise the environment itself and individual applicationsrunning within it.
10.1.3, If you can achieve command execution SQL injection or arbitrary fi leaccess within one application investigate carefully whether this providesany way to escalate your attack to target other applications.
10.2, Test Segregation Between ASP-Hosted Applications
10.2.1, If the application belongs to an ASP-hosted service composed of amix of shared and customized components identify any shared componentssuch as logging mechanisms administrative functions anddatabase code components. Attempt to leverage these to compromisethe shared portion of the application and thereby attack other individualapplications.
10.2.2, If a common database is used within any kind of shared environmentperform a comprehensive audit of the database confi guration patch leveltable structure and permissions using a database scanning tool such asNGSSquirrel. Any defects within the database security model may providea way to escalate an attack from within one application to another.
11.1, Test for Default Credentials
11.1.1, Review the results of your application mapping exercises to identify theweb server and other technologies in use that may contain accessibleadministrative interfaces.
11.1.2, Perform a port scan of the web server to identify any administrativeinterfaces running on a different port than the main target application.
11.1.3, For any identifi ed interfaces consult the manufacturer’s documentationand common default password listings to obtain default credentials.
11.1.4, If the default credentials do not work use the steps listed in section 4to attempt to guess valid credentials.
11.1.5, If you gain access to an administrative interface review the availablefunctionality and determine whether it can be used to further compromisethe host and attack the main application.Chapter 21 n A Web Application Hacker’s Methodology 847
11.2, Test for Default Content
11.2.1, Review the results of your Nikto scan (step 1.4.1) to identify any defaultcontent that may be present on the server but that is not an integral partof the application.
11.2.2, Use search engines and other resources such as www.exploit-db.com andwww.osvdb.org to identify default content and functionality includedwithin the technologies you know to be in use. If feasible carry out alocal installation of these and review them for any default functionalitythat you may be able to leverage in your attack.
11.2.3, Examine the default content for any functionality or vulnerabilities thatyou may be able to leverage to attack the server or the application.
11.3, Test for Dangerous HTTP Methods
11.3.1, Use the OPTIONS method to list the HTTP methods that the server statesare available. Note that different methods may be enabled in differentdirectories. You can perform a vulnerability scan in Paros to performthis check.
11.3.2, Try each reported method manually to confi rm whether it can in fact beused.
11.3.3, If you fi nd that some WebDAV methods are enabled use a WebDAVenabledclient for further investigation such as Microsoft FrontPage orthe Open as Web Folder option in Internet Explorer.
11.4, Test for Proxy Functionality
11.4.1, Using both GET and CONNECT requests try to use the web server as aproxy to connect to other servers on the Internet and retrieve contentfrom them.
11.4.2, Using both GET and CONNECT requests attempt to connect to different IPaddresses and ports within the hosting infrastructure.
11.4.3, Using both GET and CONNECT requests attempt to connect to commonport numbers on the web server itself by specifying 127.0.0.1 as the targethost in the request.
11.5, Test for Virtual Hosting Misconfi guration
11.5.1, Submit GET requests to the root directory using the following:n The correct Host headern A bogus Host header
11.5.2, Compare the responses to these requests. A common result is that directorylistings are obtained when the server’s IP address is used in the Hostheader. You may also fi nd that different default content is accessible.
11.5.3, If you observe different behavior repeat the application mapping exercisesdescribed in section 1 using the hostname that generated differentresults. Be sure to perform a Nikto scan using the -vhost option to identifyany default content that may have been overlooked during initialapplication mapping.
11.6, Test for Web Server Software Bugs
11.6.1, Run Nessus and any other similar scanners you have available to identifyany known vulnerabilities in the web server software you are attacking.
11.6.2, Review resources such as Security Focus Bugtraq and Full Disclosureto fi nd details of any recently discovered vulnerabilities that may nothave been fi xed on your target.
11.6.3, If the application was developed by a third party investigate whether itships with its own web server (often an open source server). If it doesinvestigate this for any vulnerabilities. Be aware that in this case theserver’s standard banner may have been modifi ed.
11.6.4, If possible consider performing a local installation of the software youare attacking and carry out your own testing to fi nd new vulnerabilitiesthat have not been discovered or widely circulated.
11.7, Test for Web Application Firewalling
11.7.1, Submit an arbitrary parameter name to the application with a clear attackpayload in the value ideally somewhere the application includes thename and/or value in the response. If the application blocks the attackthis is likely to be due to an external defense.
11.7.2, If a variable can be submitted that is returned in a server response submita range of fuzz strings and encoded variants to identify the behavior ofthe application defenses to user input.
11.7.3, Confi rm this behavior by performing the same attacks on variableswithin the application.
11.7.4, For all fuzzing strings and requests use payload strings that are unlikelyto exist in a standard signature database. Although giving examples ofChapter 21 n A Web Application Hacker’s Methodology 849these is by defi nition impossible avoid using /etc/passwd or /windows/system32/config/sam as payloads for fi le retrieval. Also avoid usingterms such as <script> in an XSS attack and using alert() or xss asXSS payloads.
11.7.5, If a particular request is blocked try submitting the same parameter in adifferent location or context. For instance submit the same parameter inthe URL in a GET request within the body of a POST request and withinthe URL in a POST request.
11.7.6, On ASP.NET also try submitting the parameter as a cookie. The APIRequest.Params[“foo”] will retrieve the value of a cookie named fooif the parameter foo is not found in the query string or message body.
11.7.7, Review all the other methods of introducing user input provided inChapter 4 picking any that are not protected.
11.7.8, Determine locations where user input is (or can be) submitted in a nonstandardformat such as serialization or encoding. If none is availablebuild the attack string by concatenation and/or by spanning it acrossmultiple variables. (Note that if the target is ASP.NET you may be ableto use HPP to concatenate the attack using multiple specifi cations of thesame variable.)
12.1, Check for DOM-Based Attacks
12.1.1, Perform a brief code review of every piece of JavaScript received fromthe application. Identify any XSS or redirection vulnerabilities that canbe triggered by using a crafted URL to introduce malicious data intothe DOM of the relevant page. Include all standalone JavaScript fi les
12.1.2, Identify all uses of the following APIs which may be used to accessDOM data that can be controlled via a crafted URL:document.locationdocument.URLdocument.URLUnencodeddocument.referrerwindow.location
12.1.3, Trace the relevant data through the code to identify what actions areperformed with it. If the data (or a manipulated form of it) is passed toone of the following APIs the application may be vulnerable to XSS:document.write()document.writeln()document.body.innerHtmleval()window.execScript()window.setInterval()window.setTimeout()
12.1.4, If the data is passed to one of the following APIs the application maybe vulnerable to a redirection attack:document.locationdocument.URLdocument.open()window.location.hrefwindow.navigate()window.open()
12.2, Check for Local Privacy Vulnerabilities
12.2.1, Review the logs created by your intercepting proxy to identify all theSet-Cookie directives received from the application during your testing.If any of these contains an expires attribute with a date that is inthe future the cookie will be stored by users’ browsers until that date.Review the contents of any persistent cookies for sensitive data.
12.2.2, If a persistent cookie is set that contains any sensitive data a local attackermay be able to capture this data. Even if the data is encrypted an attackerwho captures it will be able to resubmit the cookie to the applicationand gain access to any data or functionality that this allows.
12.2.3, If any application pages containing sensitive data are accessed overHTTP look for any cache directives within the server’s responses. If anyof the following directives do not exist (either within the HTTP headersChapter 21 n A Web Application Hacker’s Methodology 851or within HTML metatags) the page concerned may be cached by oneor more browsers:Expires: 0Cache-control: no-cachePragma: no-cache
12.2.4, Identify any instances within the application in which sensitive data istransmitted via a URL parameter. If any cases exist examine the browserhistory to verify that this data has been stored there.
12.2.5, For all forms that are used to capture sensitive data from the user (suchas credit card details) review the form’s HTML source. If the attributeautocomplete=off is not set within either the form tag or the tag for theindividual input fi eld data entered is stored within browsers that supportautocomplete provided that the user has not disabled this feature.
12.2.6, Check for technology-specifi c local storage.
12.2.6.1, Check for Flash local objects using the BetterPrivacy plug-infor Firefox.
12.2.6.2, Check any Silverlight isolated storage in this directory:C:\Users\{username}\AppData\LocalLow\Microsoft\Silverlight\
12.2.6.3, Check any use of HTML5 local storage.
12.3, Check for Weak SSL Ciphers
12.3.1, If the application uses SSL for any of its communications use the toolTHCSSLCheck to list the ciphers and protocols supported.
12.3.2, If any weak or obsolete ciphers and protocols are supported a suitablypositioned attacker may be able to perform an attack to downgrade ordecipher the SSL communications of an application user gaining accessto his sensitive data.
12.3.3, Some web servers advertise certain weak ciphers and protocols as supportedbut refuse to actually complete a handshake using these if aclient requests them. This can lead to false positives when you use theTHCSSLCheck tool. You can use the Opera browser to attempt to performa complete handshake using specifi ed weak protocols to confi rmwhether these can actually be used to access the application.
12.4, Check Same-Origin Policy Confi guration
12.4.1, Check for the /crossdomain.xml fi le. If the application allows unrestrictedaccess (by specifying <allow-access-from domain=”*” />) Flash objects
12.4.2, Check for the /clientaccesspolicy.xml fi le. Similar to Flash if the<cross-domain-access> confi guration is too permissive other sitescan perform two-way interaction with the site under assessment.
12.4.3, Test an application’s handling of cross-domain requests usingXMLHttpRequest by adding an Origin header specifying a differentdomain and examining any Access-Control headers that are returned.The security implications of allowing two-way access from any domainor from specifi ed other domains are the same as those described for theFlash cross-domain policy.
13, Follow Up Any Information Leakage
13.1, In all your probing of the target application monitor its responses forerror messages that may contain useful information about the error’scause the technologies in use and the application’s internal structureand functionality.
13.2, If you receive any unusual error messages investigate these using standardsearch engines. You can use various advanced search features tonarrow down your results. For example:“unable to retrieve” filetype:php
13.3, Review the search results looking both for any discussion about theerror message and for any other websites in which the same message hasappeared. Other applications may produce the same message in a moreverbose context enabling you to better understand what kind of conditionsgive rise to the error. Use the search engine cache to retrieve examplesof error messages that no longer appear within the live application.
13.4, Use Google code search to locate any publicly available code that maybe responsible for a particular error message. Search for snippets of errormessages that may be hard-coded into the application’s source code.You can also use various advanced search features to specify the codelanguage and other details if these are known. For example:unable\ to\ retrieve lang:php package:mail
13.5, If you receive error messages with stack traces containing the namesof library and third-party code components search for these names onboth types of search engine.
